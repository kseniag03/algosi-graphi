##  АиСД 2023 КДЗ №3

### Ганина Ксения Андреевна 212 (тг для вопросов: @kgnn47)
### CLion & IDLE python
### Выполнено
С++: генерация 3-х типов графов, 3 алгоритма на поиск кратчайших путей, замеры времени работы алгоритмов, сохранение результатов в файлы логов
Python: получение данных из файлов логов и построение графиков + их сохранение
### Не сделано: доп. алгоритм
________________________

## 1. Ориентация по проекту

Код со структурами, алгоритмами и генерацией можно посмотреть [здесь](https://github.com/kseniag03/algosi-graphi/blob/master/path-search/main.cpp)

Код с построением и сохранением графиков [здесь](https://github.com/kseniag03/algosi-graphi/blob/master/path-search/plots-gen-save.py)

Логи с данными для графиков можно посмотреть [здесь](https://github.com/kseniag03/algosi-graphi/tree/master/path-search/cmake-build-debug/logs)

Сами графики расположены [здесь](https://github.com/kseniag03/algosi-graphi/tree/master/path-search/cmake-build-debug/logs/plots)
________________________

## 2. Поясняю за графики <br>

### 2.1. Алгоритм Дейкстры O(VE)

![image](https://github.com/kseniag03/algosi-graphi/assets/114473740/9304b3dc-0065-49a9-a420-8de0a7e9bb63)

Как видим, алгоритм работает очень быстро на деревьях; сложность на полном графе возрастает линейно, на связном -- логарифмически

![image](https://github.com/kseniag03/algosi-graphi/assets/114473740/9020cd67-12e5-4476-8bbd-e9b16c4a90f4)

Скорость работы алгоритма практически не зависит от числа рёбер в случае деревьев; полный и связный граф растут одинаково, но в полном графе больше рёбер, поэтому он продолжает расти и дальше

### 2.2. Алгоритм Форда-Беллмана O(V^3)

![image](https://github.com/kseniag03/algosi-graphi/assets/114473740/c169066d-7748-47f5-a76a-46b5ccc12c09)

Тоже очень быстро работает на деревьях; в случае полного графа растёт кубически (при m == n^2) или выше, в случае связного графа -- квадратично (при m = n) или выше

![image](https://github.com/kseniag03/algosi-graphi/assets/114473740/6b556b41-d5fe-4ba4-a8cd-81dd1ba0c3b2)

Скорость работы алгоритма снова практически не зависит от числа рёбер в случае деревьев, а полный и связный меняются примерно одинаково

### 2.3. Алгоритм Флойда-Уоршелла O(V^3)

![image](https://github.com/kseniag03/algosi-graphi/assets/114473740/60149538-bcc5-4e47-a6d4-c60037a9eb0d)

Работает практически идентично на полном и связном графах; на деревьях быстрее, но не так ощутимо, как два предыдущих алгоритма

![image](https://github.com/kseniag03/algosi-graphi/assets/114473740/602ac73d-f616-433d-8459-4087014d59ba)

Уже при малом числе рёбер показывает более высокое время, чем при большом кол-ве рёбер связного или ещё большего кол-ва полного графа; медленнее всего растёт в полном графе

### 2.4. Агрегированные графики зависимости

![image](https://github.com/kseniag03/algosi-graphi/assets/114473740/10815b68-a376-4997-a520-be7101f9ebb8)

Эффективнее всего себя показывает Дейкстра на деревьях (настолько эффективно, что даже на не самом маленьком размере плоскости его график не видно...) и Дейкстра на связных <br> Менее эффективным по графику является Флойд-Уоршелл на полных и связных (однако это зависит от соотношения числа вершин и рёбер, т.к. на графике видно, что в некоторых случаях он будет работать быстрее Беллмана-Форда на полном)

![image](https://github.com/kseniag03/algosi-graphi/assets/114473740/5631e9c4-9cdd-4a31-974a-3c4d5099562b)

Флойд-Уоршелл на деревьях очень быстро растёт при небольших значениях числа рёбер, что сильно выделяет его среди других графиков (и в принципе этот алгоритм растёт быстрее остальных, т.е. он самый неэффективный); Дейкстра же наоборот -- растёт медленнее всего на всех типах графов. Беллман-Форд где-то посередине (но линии с деревьями не видно, поэтому, возможно, он тоже весьма эффективен)
________________________

## 3. Дополнения к выводам

Алгоритм Дейкстры эффективен на деревьях, т.к. в таких графах требуется обработать меньшее число вершин, что ощутимо снижает сложность; также дерево не содержит циклов, поэтому каждая пара соединена единственным путём (следовательно, алгоритм работает со сложностью, не зависящей от размера дерева)

Алгоритм Беллмана-Форда работает быстрее на деревьях, т.к. в них меньше рёбер, а алгоритм подразумевает релаксацию для каждого ребра (соот-но, чем их меньше, тем быстрее будет работать)

Алгоритм Флойда-Уоршелла очень медленно работает на деревьях, т.к. деревья содержат только один путь между двумя вершинами, и алгоритму приходится обрабатывать больше операций, что довольно избыточны; алгоритм в целом неэффективен по времени и памяти, т.к. работает с матрицей смежности и требует три вложенных цикла

